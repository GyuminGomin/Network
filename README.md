# Network Administrator 

<a href="#tcpip">TCP/IP</a> <br/>
<a href="#네트워크-일반">네트워크 일반</a> <br/>
<a href="#NOS">NOS</a> <br/>
<a href="#네트워크-운용-기기">네트워크 운용 기기</a> <br/>
<a href="#문제적-읽기">문제적 읽기</a> <br/>

<h2>TCP/IP</h2> 

<h3> - NAT - (Network Address Translation)</h3>
IP 패킷의 TCP/UDP 포트 숫자와 소스 및 목적지의 IP 주소 등을 재기록하면서 라우터를 통해 네트워크 트래픽을 주고 받는 기술  
  
<p style="color: yellow;"> NAT 사용 이유는 대개 사설 네트워크에 속한 여러 개의 호스트가 하나의 공인 IP 주소를 사용해 인터넷에 접속하기 위함  </p>  

<strong>NAT은 IPv4의 주소 부족 문제를 해결하기 위한 방법으로 고려되었으며</strong>, 주로 비공인(사설, local) 네트워크 주소를 사용하는 망에서 외부의 공인망(public)과의 통신을 위해 네트워크 주소를 변환해줌.  
  
외부 침입자가 공격하기 위해선 사설망의 내부 IP주소를 알아야 하기 때문에 공격이 어려워지므로 내부 네트워크를 보호할 수 있는 장점 존재  
  
한정된 IPv4 공인 IP 주소 절약 가능  
  
> 예시
>> 1. 공유기 하나의 공인 IP를 사설 IP로 변환하여 여러 기기 사용
>> 2. 
  
> 참고 사항  
>> 1. 백본스위치와 방화벽 사이에 설치  
>> 2. 공개된 인터넷과 사설망 사이에 방화벽(Firewall)을 설치하여 외부 공격으로 부터 보호, 이때 인터넷망과 연결하는 장비인 라우터에 NAT을 설정할 경우 라우터는 자신에게 할당된 공인 IP주소만 외부로 알려지게 하고 내부에선 사설 IP 주소만 사용해 필요시 서로 변환
>> 3. 
  
### - 라우팅 경로 결정 순서 -
```
| 라우팅 최적 경로를 결정하는 순서 |
Longest Match Rule -> AD -> Metric
```

- Longest Match Rule  
  
> 라우팅 테이블에서 목적지 경로를 찾아 갈 때, 라우팅 테이블에 있는 네트워크 주소가 가장 길게 일치되는 경로를 먼저 선택하는 방식  

예를 들어, ping 192.128.100.100을 입력했을 때, 네트워크 장비가 다음의 라우팅 테이블 정보를 가진 라우터로 송신 요청을 한다면,
```
192.0.0.0/8
192.168.0.0/16
192.168.100.0/24
```
이 중 목적지 주소가 가장 긴 경로인 192.168.100.0/24를 선택하는 것이 Longest Match Rule  

- AD (Adminstrative Distance) 값
> 라우터 간의 약속된 "관리자 거리 값"을 나타냄. 이는 관리자가 라우팅 정보 소스의 신뢰성에 대해 정해 놓은 비율로서 여러 가지 라우팅 프로토콜을 운영할 경우 동일 목적지에 대한 여러 개의 경로 중 어떤 프로토콜에 의해 얻은 정보를 우선할 것인지 그 값을 정해놓은 것

- Metric
> AD 값을 몇 번 측정했는가를 나타냄 메트릭 값은 정해진 출발지에서 목적지까지 가는 임의의 단위이며 값의 단위는 프로토콜에 따라 달라짐. 쉽게 말해 목적지까지 가기 위한 '거리 비용'이라고 생각할 수 있음.
작을수록 송신하고자 하는 라우터와 가깝고, 클수록 멀다고 볼 수 있음.

ex. 동일 라우팅 프로토콜 내에서 목적지로 가는 경로가 여러 개 있을 경우, 메트릭 값이 작을 수록 우선순위가 높아짐.

### - ARP - (Address Resolution Protocol)
IP주소를 MAC 주소와 매칭 시키기 위한 프로토콜  
  
***로컬네트워크(LAN***)에서 단말과 단말 간 통신을 하기 위해선 IP 주소와 함께 MAC 주소를 사용하게 되는데, IP 주소를 MAC Address와 매칭하여 목적지 IP의 단말이 소유한 MAC 주소를 향해 제대로 찾아가기 위함임.

이더넷같은 네트워크가 제공하는 BroadCast 기능을 사용해
목적지 IP Address에 MAC(물리적 하드웨어 주소)을 매핑하는 것, IP->MAC 주소 매핑  
*RARP(Reverse Address Resolution Protocol) : MAC->IP 주소 매핑

### - SNMP - (Simple Network Management Protocol)  
IP 기반 네트워크상의 각 호스트로부터 정기적으로 여러 관리 정보를 자동으로 수집하거나 실시간으로 상태를 모니터링 및 설정할 수 있는 서비스  

시스템이나 네트워크 관리자로 하여금 원격으로 네트워크 장비를 모니터링하고 환경설정 등의 운영을 할 수 있도록 하는 네트워크 관리 프로토콜  

SNMP 구성 요소는 기본적으로 관리 시스템과 관리 대상으로 나뉘는데, 관리 시스템을 Manager, 관리 대상을 Agent라고 부름.  

SNMP Manager은 Agent에 필요한 정보를 요청하는 모듈, SNMP Agent는 관리 대상 시스템에 설치되어 필요한 정보를 수집하고 Manager에게 전달해주는 역할 수행하는 모듈  

SNMP는 OSI 7계층의 Application 계층 프로토콜이며, 메시지는 단순 요청과 응답 형식의 프로토콜에 의해 교환되기 때문에 전송계층 프로토콜로 UDP 프로토콜 사용  

> 단점 :
>> 관리의 편의성을 주지만, 여러 취약점들이 존재해 DoS, Buffer Overflow, 비인가 접속 등 여러가지 문제점이 발생 가능

> 참고 :
>> 1. SNMP는 프로토콜일 뿐이며, 이를 활용하여 실제 네트워크 관리정보를 얻기 위해서는 관련 프로그램이 준비되어야 함.  
>> 2. 네트워크 관리를 위한 목적으로 주로 서버나 네트워크 장비에서 SNMP를 설정한 MGRT 프로그램을 이용해 트래픽 관리 등을 위해 사용됨.  
***MRGT*** : (Multiple Router Traffic Grapher)의 약자로 SNMP기반의 장비 모니터링 프로그램으로 주 용도는 네트워크 트래픽 사용량 모니터링이지만 벤더에서 제공하는 SNMP MIB값을 사용해 다양한 정보를 수집 가능

### - HTTP 상태코드 -  
- 100번대 : 정보응답  
> 100 - continue : 이 임시적인 응답은 지금까지 상태가 괜찮으며 클라이언트가 계속해서 요청을 하거나 이미 요청을 완료한 경우 무시해도 되는 것을 알려줌.  
> 101 - switching Protocol : 클라이언트가 보낸 upgrade 요청 헤더에 대한 응답에 들어가며 서버에서 프로토콜을 변경할 것임을 알려줌.  
> 102 - Processing : 서버가 요청을 수신하였으며 이를 처리하고 있지만, 아직 제대로 된 응답을 알려줄 수 없음을 알려줌.  
> 103 - Early Hints : 주로 Link 헤더와 함께 사용되며 서버가 응답을 준비하는 동안 사용자 에이전트가(user agent) 사전 로딩을 시작할 수 있도록 함.  

- 200번대 : 성공응답  
> 200 - OK : 요청이 성공적으로 되었습니다. 성공의 의미는 HTTP 메소드에 따라 달라짐.  
> ***GET*** : 리소스를 불러와서 메시지 바디에 전송되었습니다.  
> ***HEAD*** : 개체 헤더가 메시지 바디에 있습니다.  
> ***PUT or POST*** : 수행 결과에 대한 리소스가 메시지 바디에 전송되었습니다.  
> ***TRACE*** : 메시지 바디는 서버에서 수신한 요청 메시지를 포함하고 있습니다.  
> 201 - Created : 요청이 성공적이었으며, 그 결과로 새로운 리소스가 생성. 이 응답은 주로 POST 요청 또는 일부 PUT 요청 이후에 따라옴.  
> 202 - Accepted : 요청을 수신하였지만 그에 응하여 행동할 수 없음. 이 응답은 요청 처리에 대한 결과를 이후에 HTTP로 비동기 응답을 보내는 것에 대해 명확하게 명시하지 않는다. 이것은 다른 프로세스에서 처리 또는 서버가 요청을 다루고 있거나 배치 프로세스를 하고 있는 경우를 위해 만들어짐.  
> 203 - Non-Authoritative Information : 이 응답 코드는 돌려받은 메타 정보 세트가 오리진 서버의 것과 일치하지 않지만 로컬이나 서드 파티 복사본에서 모아졌음을 의미함. 이러한 조건에선 이 응답이 아니라 200 OK 응답을 반드시 우선됨.  
> 204 - No Content : 요청에 대해서 보내줄 수 있는 콘텐츠가 없지만, 헤더는 의미있을 수 있음. 사용자-에이전트는 리소스가 캐시된 헤더를 새로운 것으로 업데이트 할 수 있음.  
> 205 - Reset Content : 요청을 완수한 후 사용자 에이전트에게 이 요청을 보낸 문서 뷰를 리셋하라고 알려줌.  
> 206 - Partial Content : 클라이언트에서 복수의 스트림을 분할 다운로드 하고자 범위 헤더를 전송했기 때문에 사용됨.  
> 207 - Multi-Status : 멀티-상태 응답은 여러 리소스가 여러 상태 코드인 상황이 적절한 경우 해당되는 정보를 전달  
> 208 - Multi-Status : DAV에서 사용됨. propstat(Property와 status의 합성어) 응답 속성으로 동일 컬렉션으로 바인드된 복수의 내부 멤버를 반복적으로 열거하는 것을 피하기 위해 사용됨.  
> 226 - IM Used : 서버가 GET 요청에 대한 리소스의 의무를 다 했고, 응답이 하나 또는 그 이상의 인스턴스 조작이 현재 인스턴스에 적용 되었음을 알려줌.  

- 300번대 : 리다이렉션 메시지  
> 300 - Multiple Choice : 요청에 대해 하나 이상의 응답이 가능, 사용자 에이전트 또는 사용자는 그 중 하나를 반드시 선택해야 함. 응답 중 하나를 선택하는 방법에 대한 표준화 된 방법은 존재하지 않음.  
> 301 - Moved Permanently : 요청한 리소스의 URL가 변경되었음을 의미함. 새로운 URI가 응답에서 주어질 수 있음.  
> 302 - Found : 리소스의 URI가 일시적으로 변경되었음을 의미함. 새롭게 변경된 URI는 나중에 만들어질 수 있음. 그러므로, 클라이언트는 향후 요청도 반드시 동일한 URI로 해야함.  
> 303 - See Other : 클라이언트가 요청한 리소스를 다른 URI에서 GET 요청을 통해 얻어야 할 때, 서버가 클라이언트로 직접 보내는 응답임.  
> 304 - Not Modified : 캐시를 목적으로 사용됨. 이것은 클라이언트에게 응답이 수정되지 않았음을 알려주며, 클라이언트는 계속해서 응답의 캐시된 버전을 사용할 수 있음.  
> 307 - Temporary Redirect : 클라이언트가 요청한 리소스가 다른 URI에 있으며, 이전 요청과 동일한 메소드를 사용하여 요청해야할 때, 서버가 클라이언트에 이 응답을 직접 보냄. 이것은 302 Found HTTP 응답코드와 동일한 의미를 가지고 있으며, 사용자 에이전트가 반드시 사용된 HTTP 메소드를 변경하지 말아야 하는 점만 다름: 만약 첫 요청에 POST가 사용되었다면, 두 번째 요청도 반드시 POST를 사용.  
> 308 - Permanent Redirect : 리소스가 이제 HTTP 응답 헤더의 Location: 에 명시된 영구히 다른 URI에 위치하고 있음을 의미함. 이것은 301 Moved Permanently HTTP 응답 코드와 동일한 의미를 갖고 있으며, 사용자 에이전트가 반드시 HTTP 메소드를 변경하지 말아야 하는 점만 다름: 만약 첫 요청에 POST가 사용되었다면, 두 번째 요청도 반드시 POST 사용.  

- 400번대 : 클라이언트 에러 응답  
> 400 - Bad Request : 잘못된 문법으로 인하여 서버가 요청을 이해할 수 없음을 의미함.  
> 401 - Unauthorized : 비록 HTTP 표준에선 "미승인(unauthorized)"를 명확히 하고 있지만, 의미상 이 응답은 "비인증(unauthenticated)"을 의미함. 클라이언트는 요청한 응답을 받기 위해 반드시 스스로를 인증해야 함.  
> 403 - Forbidden : 클라이언트는 콘텐츠에 접근할 권리를 가지고 있지 않음. 예를들어 그들은 미승인이어 서버는 거절을 위한 적절한 응답을 보내고, 401과 다른점은 서버가 클라이언트가 누구인지 알고 있음.  
> 404 - Not Found : 서버는 요청받은 리소스를 찾을 수 없음. 브라우저에선 알려지지 않은 URL을 의미함. 이것은 API에서 종점은 적절하지만, 리소스 자체는 존재하지 않음을 의미할 수도 있음. 서버들은 인증받지 않은 클라이언트로부터 리소스를 숨기기 위해 이 응답을 403 대신에 전송할 수도 있음.  
> 405 - Method Not Allowed : 요청한 메소드는 서버에서 알고 있지만, 제거되었고 사용할 수 없음. 예를 들어, 어떤 API에서 리소스를 삭제하는 것을 금지할 수 있음. 필수적인 메소드인 GET과 HEAD는 제거될 수 없으며 이 에러 코드를 리턴할 수 없음.  
> 406 - Not Acceptable : 서버가 <a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Content_negotiation#%EC%84%9C%EB%B2%84_%EC%A3%BC%EB%8F%84_%EC%BB%A8%ED%85%90%EC%B8%A0_%ED%98%91%EC%83%81">서버 주도 콘텐츠 협상</a>을 수행한 이후, 사용자 에이전트에서 정해준 규격에 따른 어떠한 콘텐츠도 찾지 않았을 때, 웹서버가 보냄.  
> 407 - Proxy Authentication Required : 401 Unauthorized와 비슷하지만 프록시에 의해 완료된 인증이 필요함.  
> 408 - Request Timeout : 이 응답은 요청을 한지 시간이 오래된 연결에 일부 서버가 전송하며, 어떨때에는 이전에 클라이언트로부터 어떠한 요청이 없었다고 하더라도 보내지기도 함. 이것은 서버가 사용되지 않는 연결을 끊고 싶어한다는 것을 의미함.  
> 409 - Conflict : 요청이 현재 서버의 상태와 충돌될 때 보냄.  
> 410 - Gone : 요청한 콘텐츠가 서버에서 영구적으로 삭제되었으며, 전달해 줄 수 있는 주소 역시 존재하지 않을 때 보냄. 클라이언트가 그들의 캐쉬와 리소스에 대한 링크를 지우기를 기대함. HTTP 기술 사양은 이 상태 코드가 "일시적인, 홍보용 서비스"에 사용되기를 기대함. API는 알려진 리소스가 이 상태 코드와 함께 삭제되었다고 강요해선 안됨.  
> 411 - Length Required : 서버에서 필요로 하는 Content-Length 헤더 필드가 정의되지 않은 요청이 들어왔기 때문에 서버가 요청을 거절함.  
> 412 - Precondition Failed : 클라이언트의 헤더에 있는 전제조건은 서버의 전제조건에 적절하지 않음.  
> 413 - Payload Too Large : 요청 엔티티는 서버에서 정의한 한계보다 큼. 서버는 연결을 끊거나 혹은 Retry-After 헤더 필드로 돌려보낼 것.  
> 414 - URI Too Long : 클라이언트가 요청한 URI는 서버에서 처리하지 않기로 한 길이보다 김.  
> 415 - Unsupported Media Type : 요청한 미디어 포맷은 서버에서 지원하지 않음. 서버는 해당 요청 거부  
> 416 - Requested Range Not Satisfiable : Range 헤더 필드에 요청한 지정 범위를 만족시킬 수 없음. 범위가 타겟 URI 데이터의 크기를 벗어났을 가능성이 있음.  
> 417 - Expectation Failed : Expect 요청 헤더 필드로 요청한 예상이 서버에선 적당하지 않음을 알려줌.  
> 418 - I'm a teapot : 서버는 커피를 찻 주전자에 끓이는 것을 거절함.  
> 421 - Misdirected Request : 서버로 유도된 요청은 응답을 생성할 수 없음. 이것은 서버에서 요청한 URI와 연결된 스킴과 권한을 구성하여 응답을 생성할 수 없을 때 보내짐.  
> 422 - Unprocessable Entity : 요청은 잘 만들어졌지만, 문법 오류로 인해 따를 수 없음.  
> 423 - Locked : 리소스는 접근하는 것이 잠겨있음.  
> 424 - Failed Dependency : 이전 요청이 실패하였기 때문에 지금의 요청도 실패함.  
> 426 - Upgrade Required : 서버는 지금의 프로토콜을 사용하여 요청을 처리하는 것을 거절하였지만, 클라이언트가 다른 프로토콜로 업그레이드를 하면 처리를 할지도 모름. 서버는 Upgrade 헤더와 필요로 하는 프로토콜을 알려주기 위해 426 응답에 보냄.  
> 428 - Precondition Required : 오리진 서버는 요청이 조건적이어야 함. 클라이언트가 리소스를 GET해서, 수정하고 PUT으로 서버에 돌려놓는 동안 서드파티가 서버의 상태를 수정하여 발생하는 충돌인 '업데이트 상실'을 예방하기 위한 목적임.  
> 429 - Too Many Requests : 사용자가 지정된 시간에 너무 많은 요청을 보냄.  
> 431 - Request Header Fields Too Large : 요청한 헤더 필더가 너무 크기 때문에 서버는 요청을 처리하지 않을 것. 요청은 크기를 줄인 다음 다시 전송해야 함.  
451 - Unavailable For Legal Reasons : 사용자가 요청한 것은 정부에 의해 검열된 웹 페이지와 같은 불법적인 리소스임.  
- 500번대 : 서버 에러 응답  
> 500 - Internal Server Error : 서버가 처리 방법을 모르는 상황이 발생함. 서버는 아직 처리 방법을 알 수 없음.  
> 501 - Not Implemented : 요청 방법은 서버에서 지원되지 않으므로 처리할 수 없음. 서버가 지원해야 하는 유일한 방법은 GET과 HEAD임. 이 코드는 반환하면 안됨.  
> 502 - Bad Gateway : 서버가 요청을 처리하는 데 필요한 응답을 얻기 위해 게이트웨이로 작업하는 동안 잘못된 응답을 수신했음을 의미함.  
> 503 - Service Unavailable : 서버가 요청을 처리할 준비가 되지 않음. 일반적인 원인은 유지보수를 위해 작동이 중단되거나 과부하가 걸렸을 경우. 이 응답과 함께 문제를 설명하는 사용자 친화적인 페이지가 전송되어야 함. 이 응답은 임시 조건에 사용되어야 하며, Retry-After : HTTP헤더는 가능하면 서비스를 복구하기 전 예상 시간을 포함해야 함. 웹 마스터는 또한 이러한 일시적인 조건 응답을 캐시하지 않아야 하므로 이 응답과 함께 전송되는 캐싱 관련 헤더에 대해서도 주의해야 함.  
> 504 - Gateway Timeout : 서버가 게이트웨이 역할을 하고 있으며, 적시에 응답을 받을 수 없을 때 주어짐.  
> 505 - HTTP Version Not Supported : 요청에 사용된 HTTP 버전은 서버에서 지원되지 않음.  
> 506 - Variant Also Negotiates : 서버에 내부 구성 오류가 있음. 즉, 요청을 위한 투명한 컨텐츠 협상이 순환 참조로 이어짐.  
> 507 - Insufficient Storage : 서버에 내부 구성 오류가 있음. 즉, 선택한 가변 리소스는 투명한 콘텐츠 협상에 참여하도록 구성되므로 협상 프로세스의 적절한 종료 지점이 아님.  
> 508 - Loop Detected : 서버가 요청을 처리하는 동안 무한 루프를 감지함.  
> 510 - Not Extended : 서버가 요청을 이행하려면 요청에 대한 추가 확장이 필요함.  
> 511 - Network Authentication Required : 511 상태 코드는 클라이언트가 네트워크 액세스를 얻기 위해 인증을 받아야 할 필요가 있음을 나타냄.

### - ICMP -  (Internet Control Message Protocol)  
<> 네트워크 내 장치가 데이터 전송과 관련된 문제를 전달하기 위해 사용하는 <strong>***3계층 네트워크***</strong> 프로토콜임.  
ICMP 정의에서 ICMP가 사용되는 주요 방법 중 하나는 데이터가 대상에 도달하는지와 도달 시간이 적절한지를 확인하는 것임. 따라서 ICMP는 네트워크가 데이터를 얼마나 잘 전송하는지 알 수 있는 오류 보고 프로세스 및 테스트의 중요한 측면임. 그러나 DDoS 공격을 실행하는데에도 사용할 수 있음.  

<> 또한 네트워크 성능을 평가하기 위한 진단 도구임.  
트레이스 라우트와 핑 모두 ICMP를 사용함. 트레이스 라우트와 핑은 데이터가 정상적으로 전송되었는가에 대해 전송되는 메시지로, 트레이스 라우트를 사용하면 데이터 패킷이 대상에 도달하기 위해 통과한 장치가 보고서에 표시됨. 여기엔 데이터를 처리하기 위한 물리적 라우터가 포함됨.  
트레이스 라우트는 또한 데이터가 한 장치에서 다른 장치로 이동하는 데 걸리는 시간을 알려줌. 라우터 간 데이터의 이동을 홉(hop)이라고 하며 트레이스 라우트에 의해 파악한 정보로 경로 중 지연을 일으키는 장치를 파악할 수 있음.  
핑은 트레이스 라우트와 비슷하지만, 더 간단함. 그것은 데이터가 두 지점 간을 이동하는 데 걸리는 시간을 알려줌. ICMP는 에코 요청 및 에코 응답이 핑 프로세스 중에 사용된다는 점에서 p핑을 용이하게 함.  

<> 또한 ICMP는 네트워크 성능을 저하시키는 데도 사용함. 이 작업은 ICMP 서비스 장애, 스머프 공격 및 네트워크 상의 장치를 압도하고 정상적인 기능을 방해하는 PoD 공격으로 수행됨.  

> 메시지 타입
>> 0 - Echo reply : Echo 메시지의 응답 (ping의 응답)  
>> 3 - Destination unreachable : 도달 불가 에러 (Code에 더 자세한 에러사유)  
>> 4 - Source quench : congestion control의 용도  
>> 5 - Redirect : 더 빠른 경로가 있다고 알려줄 때  
>> 8 - Echo request : Echo 메시지의 요청 (ping의 요청)  
>> 11 - Time exceeded : TTL이 초과된 경우  
>> 13 - Timestamp Request
>> 30 - Trace route : 해당 라우터까지 가는 경로 체크용  
>> 15~18 - 정보 주고받기 관련 : DHCP가 이제 이 역할을 대신함.  
>>> 17 - Address Mask Request

### - CSMA/CD - (Carrier Sense Multiple Access/Collision Detection)
LAN의 통신 프로토콜 종류중 하나이며, 이더넷 환경에서 사용  
***IEEE 802.3 규격***

> 방식
>> 이더넷 환경에서 통신하고 싶은 PC나 서버는 먼저 네트워크 상에 통신이 일어나는지 확인을 함. (캐리어가 있는지 검사)
*캐리어 : 네트워크 상에 나타나는 신호  
>> 네트워크 통신이 일어나고 있으면 (캐리어가 감지되면) 데이터를 보내지 않고 기다림.  
>> 네트워크 통신이 일어나고 있지 않으면 (캐리어가 감지되지 않으면) 데이터를 네트워크 상에 보냄.  
>> 만약, 캐리어가 감지되지 않았을 때, 두 PC나 서버가 데이터를 동시에 보내면 이 경우를 Multiple Access(다중 접근)이라고 함.  
>> 위 처럼 두 PC나 서버가 데이터를 동시에 보내려다 부딪치는 경우 충돌(Collision)이 발생했다고 함.  
>> 만약, 충돌이 일어나게 된다면 데이터를 전송했던 두 PC나 서버들은 랜덤한 시간 동안 기다린 다음 다시 데이터를 전송함.  
>> 이런 충돌이 계속해서 ***15***번 일어나면 통신을 끊음.  

1. CSMA/CD 충돌 x  
    1. 전송을 원하는 호스트는 네트워크에서 캐리어를 감지해 전송이 가능한지 검사.  
    1. 전송이 가능할 경우, 브로드캐스트를 해 목적지 Address를 찾아냄. (여기서 목적지 Address는 유니캐스트로 응답)  
    1. 그 후 전송

1. CSMA/CD 충돌 o
    1. 전송을 원하는 호스트는 네트워크에서 캐리어를 감지해 전송이 가능한지 검사
    1. 다른 PC에서 발생한 프레임이 공유매체에서 충돌이 발생함.
    1. 충돌이 발생하면 Jam Signal을 모든 호스트로 전송해 충돌 발생에 대해 알리고, Jam Signal을 받으면 일정 시간 뒤 다시 전송을 함.

### - OSPF - (Open Shortest Path First)  
`링크상태 라우팅 프로토콜(Link State 알고리즘)에 기반하여, 자치 시스템(AS) 내부의 라우터들끼리(IGP) 라우팅 정보를 교환하는 라우팅 프로토콜`

> 특징
>> Interior Gateway Protocol(IGP)에 속함 : 동일 자치시스템(AS) 내에 있는 라우터끼리만 라우팅  
>> Link State 기술에 의한 최단경로 선택 라우팅 알고리즘 : 최단 경로를 선택하기 위해 Dijkstra의 SPF(Shortest Path First) 알고리즘 사용  
>> 빠른 재수렴 (Fast Reconvergence) 및 부분 갱신 (Partial Update) : OSPF 라우터 각각이 전체 네트워크 토폴로지 정보를 가지므로, 토폴로지 변화에 빠른 대처 가능 및 네트워크가 안정되면 라우팅 갱신 정보 만 전달  
>> 라우팅 메트릭으로 링크 비용 사용 : 목적지까지의 최적 경로 선택을 위한 라우팅 메트릭으로는 Link Cost 사용  
>> 라우터 인터페이스에 접속된 OSPF 네트워크 종류에 따라 동작 방식이 달라짐  
>> VLSM(Variable Length Subnet Mask) 및 CIDR(Classless InterDomain Routing) 지원  

### - IGMP -  (Internet Group Management Protocol)
호스트(컴퓨터)가 멀티캐스트 그룹 구성원을 인접한 라우터에게 알리는 프로토콜  
TCP/IP 프로토콜 집합이 동적 멀티캐스팅을 수행하기 위해 사용하는 표준 프로토콜 (멀티 캐스트 : 한 소스에서 선택된 대상 그룹의 통신을 지원하는 네트워크 전송의 유형)  
***IGMP, ICMP는 데이터 전송용 프로토콜이 아니고 이벤트 또는 변화를 알리는데 사용되는 프로토콜***  

> IGMP 동작  
>> 1. 그룹 멤버쉽 조사 (Monitoring) : 멤버쉽 질의 메시지를 보내 응답을 기다림. 일정 횟수 이상 응답 없으면 라우터는 해당 호스트를 그룹에서 탈퇴 시킴.  
>> 2. 그룹 가입 (Joining) : 그룹에 가입하고자 하는 요청을 라우터에 보고  
>> 3. 멤버쉽 연속 (Member continuation) : 계속해서 유지하기 원하는 보고 메시지  
>> 4. 그룹 탈퇴 (Leaving) : 호스트가 해당 그룹의 멀티캐스트 트래픽을 원치 않으면 leave 메시지 전송

> IGMP 기타 기능
>> IGMP Snooping : 라우터와 호스트 사이에 있는 스위치가 IGMP 메시지들을 들을 수 있는 기능  
>> IGMP Querier Election : 동일 LAN에 여러 멀티캐스트 라우터가 있으면, IPv4 주소 중 가장 낮은 주소를 갖는 라우터가 Querier역할을 집중하게 함.

### ZigBee
`IEEE 802.15.4-2003을 기반으로 한 작고, 저전력의 디지털 라디오를 사용하는 하이레벨 통신 프로토콜, IEEE 802.15.4-2003는 단거리 라이도 주파수를 사용하는 램프, 전자계량기, 소비자용 전자제품과 같은 근거리 개인 무선통신망의 기준.`




<h2>네트워크 일반</h2>

### - WMN - (Wireless Mesh Network)
무선 네트워크로 새로운 링크를 동적으로 설정하고 다른 노드와 연결하는 기술.  

Mesh는 네트워킹 주파수 대역에 따라 다중 주파수 다중 채널 네트워킹과 단일 주파수 네트워킹으로 나뉨. 단일 주파수 네트워크 송수신은 단일 주파수를 사용하며, 대역폭 용량은 절반으로 줄어듬. 다중 주파수 다중 채널 네트워킹에서 장치는 서로 다른 링크에 대해 다중 직교 주파수를 사용하므로 시스템 처리량이 증가할 수 있음.  

무선 주파수 기술은 전송률 및 성능 향상을 위해 OFDM, MIMO, 스마트 안테나 등의 기술이 널리 사용되고 있음.  

자원 스케줄링 측면에서 일반적으로 CSMA/CD 모드와 TDMA 모드로 구분됨. CSMA/CA는 자원 경쟁 모드를 채택하지만 노드와 홉의 수가 많고 네트워크 부하가 높을 때 실효 자원 활용률이 낮음. TDMA 모드는 시간 할당을 기반으로 하는 스케줄링 메커니즘으로 네트워크 부하가 높을 때 효율성이 높음.  

네트워크 라우팅 알고리즘 측면에서 고정 경로에서 사용되는 RIP 및 OSPF 라우팅 프로토콜과 달리 일반적인 메시 무선 라우팅 알고리즘에선 DSDV, DSR, AODV 등이 포함됨.

> 장점
>> 자체 구성 네트워크, 자체 복구, 다중 홉 계단식 및 노드 자체 관리의 장점이 있음.  
>> 장비 배치가 빠르고 설치가 쉬움.  
>> 가시선이 아닌 전송(NLOS) : 데이터 전송 지점의 경우 데이터는 전송 지점에 대한 직접적인 시선을 가진 장치 또는 사용자가 먼저 수락하고 수신 장치와 사용자는 AP이며, 직접 장치에 도달하기 위해 데이터를 계속 전달할 수 있음.  
>> 네트워크 안전성 : 다른 노드를 통해 데이터를 전송할 수 있음. 하나 또는 일부 노드에 장애가 발생하거나 간섭이 발생하면, 다른 작업 노드를 통해 데이터를 전송 가능.  
>> 고대역폭 : 무선 통신의 물리적 특성은 통신 전송 거리가 짧을수록 높은 대역폭을 얻기 쉽고 간섭이 적음을 결정함. 따라서 여러 개의 짧은 홉 전송 데이터를 선택하면 네트워크에서 더 높은 대역폭을 얻을 수 있으며 한 노드는 동시에 정보를 주고 받을 수 있을 뿐만 아니라 라우터 역할을 하여 다른 노드에 정보를 전달함. 노드의 수가 증가하고 전파 경로의 수가 증가함에 따라 총 대역폭이 크게 증가함.

### - NFV - (Network Functions Virtualization)  
기존의 네트워크 하드웨어 장비를 소프트웨어 형태로 가상화하는 개념  
라우터, 방화벽, 로드밸런서, IDS, IPS, DNS, 캐싱 등의 물리적인 네트워크 기능을 여러 사용자 또는 필요한 리소스(서버, 스토리지 등)에서 사용할 수 있는 것  
NFV 또한 일반적인 리소스 가상화의 특징을 그대로 가지고 있음.  
네트워크 기능이 가상화 됨으로써 값비싼 장비와 전용 솔루션 대신 저렴한 범용 하드웨어를 사용할 수 있음. 네트워크 인프라를 구축하고 운영함에 있어서 유연성과 효율성이 높아짐은 당연함.  
이는 특히 SDN 환경에서 큰 효과를 발휘한다.  

### QOS (Quality of Service)
`한정된 네트워크 용량으로 트래픽을 제어하고 주요 애플리케이션의 성능을 보장하기 위해 메커니즘이나 기술을 활용하는 것` -> 이를 통해 조직은 특정 고성능 애플리케이션들의 우선순위를 정하여 전체 네트워크 트래픽을 조정할 수 있음.  

- 일반적으로 리소스 집약적 시스템의 트래픽을 전달하는 네트워크에 적용
- 네트워킹에서 QoS 설정을 사용하는 조직은 네트워크에서 여러 개의 애플리케이션 성능을 동시에 최적화하고 네트워크의 비트 전송률, 전송 지연, 지터, 패킷 속도에 대한 가시성을 확보할 수 있음.
- QoS의 의미에 따라, 핵심 목표는 네트워크와 조직이 대역폭이 전용인지, 지터가 제어되는지, 대기 시간은 어느 쪽이 짧은지를 고려하여 그래픽 우선순위를 정할 수 있도록 하는 것

### IPv6 특징
1. 128비트 주소공간 제공
2. 호스트 주소 자동 설정 (IPv4는 주소를 자동할당받기 위해 DHCP를 사용)
3. 패킷 크기 확장 (주고받는 패킷 크기 IPv4는 64kbyte로 제한)
4. 효율적인 라우팅(헤더 형태의 변형)
5. Flow Labeling
6. 인증 및 보안 기능
7. 네트워크 물리적 위치에 제한받지 않고 같은 주소를 유지하면서도 자유롭게 이동 가능
8. 헤더 정보가 IPv4에 비해 간략함
9. 패킷 전송 시 멀티캐스트 사용

### WDM(파장분할다중화방식) Wavelength Division Multiplexing

`하나의 광섬유에 입력 채널 신호들을 각기 다르게 할당된 채널 파장대역을 통해 동시에 전송하는 광 다중화 방식`

- 각 입력 채널 마다 다른 각각의 파장대역을 할당하게 됨

> 특징
>> FDM 방식의 일종인 파장 다중화 방식
>> - 복수의 전달 정보를 각기 다른 파장에 할당하여 하나의 광섬유에 전송
>> - 여러 개의 광 파장을 하나의 광섬유를 통하여 전송, 광코어의 수를 줄임
>> - 선로의 증설없이 회선증설이 용이, 전송거리를 TDM 방식보다 더 길게 할 수 있음  

>> 투명성
>> - 서로 다른 전송률과 프로토콜을 갖는 파장 채널들로 공존 가능  

>> 네트워크 구성 용이
>> - 광수동소자 만으로 쉽게 분기결합 구현 가능  

>> 확장성
>> - 광섬유 추가 포설이나 전송장비의 교체 없이, 다른 파장의 채널을 간단히 추가해주는 것 만으로도 전송용량을 쉽게 확장 가능

>> 장거리 통신
>> - 중간에 광손실 보상을 위해 광증폭기가 사용 됨  

### IP 주소 체계(IPv4) 와 클래스

`IP 주소 : 네트워크 주소 부분 + 호스트 주소 부분`

- 호스트 주소 : 네트워크 안에 있는 IP기기를 구분하는데 사용
- 네트워크 주소 : 네트워크들 간 네트워크를 식별하기 우해 사용

`cf. 네트워크에서 가용 가능한 호스트 주소의 개수를 환산할 땐 : 네트워크 주소와 호스트 주소를 뺀 첫번째와 마지막 주소는 할당 불가`

- 네트워크 주소
    - A 클래스 : 0.0.0.0 ~ 127.255.255.255
    - B 클래스 : 128.0.0.0 ~ 191.255.255.255
    - C 클래스 : 192.0.0.0 ~ 223.255.255.255
    - D 클래스 : 224.0.0.0 ~ 239.255.255.255
    - E 클래스 : 240.0.0.0 ~ 255.255.255.255


<h2>NOS</h2>  

### FTP 모드 (File Transfer Protocol)

`하나의 호스트에서 다른 호스트로 파일을 복사하기 위해 TCP/IP에 의해 제공되는 표준 통신 프로토콜`  
- Active 모드 : default
1. 클라이언트는 서버의 21번 포트로 연결을 요청 (ex. 6121 port)
2. 서버는 클라이언트의 요청에 대한 응답
3. 서버의 Data포트(20번)는 클라이언트가 알려준 Data포트(6121)로 연결 요청
4. 클라이언트가 서버의 요청에 대한 응답 (연결완료)
    - `서버가 클라이언트에 접속`
- Passive 모드
1. 클라이언트는 서버의 21번 포트에 Passive Mode로 연결 요청
2. 서버는 클라이언트의 요청에 대한 응답, 이때 서버의 Data 전송 포트번호가 1025 라는 것을 알려줌
3. 클라이언트의 Data 전송 포트인 6121에서 서버의 Data 전송 포트인 1025 포트로 데이터 채널 연결 요청
4. 서버가 클라이언트에 대한 요청을 응답하며 연결 완료
    - `클라이언트가 서버에 접속`

### DNS의 레코드  

`DNS Record는 DNS 서버가 해당 패킷을 받았을 때 어떤식으로 처리할지를 나타내는 지침.`  
  
cf) 서버 클러스터는 디바이스 간 요청을 분산하기 때문에 DNS SOA 레코드가 필요함. 이를 통해 시스템 장애로 이어질 수 있는 특정 서버의 과부하 방지 가능

> 레코드 종류
>> A : 해당 도메인 주소가 가지는 IP

>> CNAME : 별칭을 부여한 특정 도메인 주소

>> MX : 메일을 주고 받기 위한 서비스 레코드

>> SOA : 도메인의 시작점(Start Of Authority)
>>  - 네임 서버가 해당 도메인에 관하여 인증된 데이터를 가지고 있음을 증명하는 레코드
>>  - 기본 이름 서버, 도메인 관리자의 전자 메일, 도메인 일련 번호 및 영역 새로 고침과 관련된 여러 타이머를 포함하여 DNS 영역에 대한 핵심 정보를 지정  
>>  - SOA 레코드가 없는 도메인은 네임서버에서 정상적으로 동작하지 않음
>>  - Zone 파일
>>      - DNS를 설정하는 zone파일은 항상 SOA 레코드로 시작
>>      - Serial 필드 : 도메인의 갱신 버전 번호
>>      - Refresh 필드 : 도메인 영역의 데이터 갱신 여부를 체크하는 주기(초 단위)
>>      - Retry 필드 : refresh 주기로 체크하지 못했을 경우, 체크 재시도 주기(초 단위)
>>      - Expire 필드 : retry의 주기로 체크를 수차례 반복하다, 도메인을 더이상 신뢰할 수 있는 영역이라고 간주하지 않아 서비스를 중단하는 최대 기한
>>      - Minimum 필드 : 도메인을 찾을 수 없는 경우, 네임 서버가 도메인의 부재정보를 캐싱하는 시간
>>      - MName 필드 : 도메인에 대한 기본 호스트 네임
>>      - RName 필드 : 관리자의 이메일 주소

### find 명령어
`-exec : 찾은 파일에 대한 삭제 등의 추가적인 명령을 실행 가능`

### Windows 의 이벤트 뷰어를 통해 서버 상태 점검
- windows 로그
    - 응용 프로그램
- 인증서 키 복원
    - certmgr.msc

### Multihoming
`인터넷에 다중 접속하는 기술로서 단일 인터넷 연결만으로는 제공하기 어려운 요구 사항인 오류 예방, 로드 분산 등을 효율적으로 제공할 수 있음`




<h2>네트워크 운용 기기</h2> 

### RAID (Redundant Array of Independent Disk)

`여러 디스크를 하나로 묶어 마치 한 디스크처럼 사용하거나, 디스크가 고장 나더라도 디스크 안에 있는 데이터를 보호하기 위해 고안된 기술`  

- 하드웨어적인 방법
    - 별도의 어댑터 카드나 메인보드 속 내장 칩을 통해 RAID를 구성하는 경우
    - 이 방법을 사용할 시 운영체제에 이 디스크가 하나의 디스크처럼 보이게 함

- 소프트웨어적인 방법
    - 운영체제에서 구현되며, 사용자에게 디스크를 하나의 디스크처럼 보이게 함  
    - 운영체제는 여러 개의 디스크로 인식하며, 하드웨어적 구성에 비해 성능향상 폭이 작고 안전성도 떨어짐  

>- RAID 0 (스트라이프 세트)
>    - 최소 드라이브 개수 : 2  
>    - 최대 용량 : 디스크의 수 x 디스크의 용량 (그치만 용량이 다른 거로 넣으면, 큰 디스크가 작은 디스크 크기로 대체됨)  
>    - 설명 : 데이터를 블럭으로 쪼개서 저장하는데 각 블럭은 다른 디스크로 나뉘어 저장된다.

> 장점
> 1. 매우 빠름 (데이터는 여러 개의 모터(spindles)로 스토리지에서 읽고 씀. 즉, I/O 로드가 분산되는 것을 의미하기 때문에 매우 빠름)

> 단점
> 1. 매우 위험하다. (드라이브가 하나라도 고장나면 RAID 0에는 어떤 안전장치도 없기 때문에 전체 디스크 배열이 고장 날 수 있다. 디스크를 추가할 수록 위험이 증가한다.)
---
> - Raid 1 (디스크 미러링)
>    - 최소 드라이브 개수 : 2
>    - 최대 용량 : 디스크의 용량
>    - 설명 : 스토리지에 저장되는 모든 데이터는 N개의 물리적인 디스크에 각각 저장되고 모든 데이터는 중복됨. 서버 또는 연구목적 PC에서 혹시 모를 데이터 손실에 대비하기 위해 사용

> 장점
> 1. 드라이브 하나가 고장나도 똑같은 내용의 다른 드라이브가 하나 더 있기 때문에 매우 안전함. RAID 1은 읽기 성능이 단일 드라이브에서의 성능과 같거나 훨씬 좋음.

> 단점
> 1. 각 드라이브는 미러링되기 때문에 전체 용량의 절반밖에 사용하지 못함. 드라이브 두 개에 동일한 데이터를 써야 하기 때문에 쓰기 성능이 나쁨.
---
> - RAID 0+1
>   - 최소 드라이브 개수 : 4
>   - 최대 용량 : 디스크의 수 / (RAID 0로 묶는 디스크 개수) x 디스크 용량
>   - 설명 : RAID 0으로 먼저 묶고, 그 다음 RAID 1로 묶는 방법. 디스크 N개를 A개씩 RAID 0로 묶고, RAID 0로 스트라이핑 된 볼륨 N/A개를 RAID 1로 미러링  

> 장점
> 1. RAID 0의 속도와 RAID 1의 안전성이라는 각 장점을 합침. RAID 10에 비해 기술적으로 단순함  

> 단점
> 1. RAID 10에 비해 확률적으로 안전성이 떨어짐. 복구 시간이 오래 걸림
---
> - RAID 10
>   - 최소 드라이브 개수 : 4
>   - 최대 용량 : 디스크의 수/(RAID 1로 묶는 디스크 개수) x 디스크 용량
>   - 설명 : RAID 1으로 먼저 묶고, 그 다음 RAID 0로 묶는 방법. 디스크 N개를 A개씩 RAID 1로 묶고, RAID 1로 미러링 된 볼륨 N/A개를 RAID 0으로 스트라이핑 함.

> 장점
> 1. RAID 0의 속도와 RAID 1의 안전성이라는 장점을 합침. RAID 0+1에 비해 디스크 장애 발생시 복구가 수월함

> 단점
> 1. 기술적으로 복잡함
---

> - RAID 2
>   - 오류정정부호(ECC)를 기록하는 전용의 하드디스크를 이용해 안전성을 확보함. RAID 2는 비트 단위에 Hamming Code를 적용함. 때문에 하나의 멤버 디스크가 고장나도 ECC를 이용해 정상적으로 작동할 수 있지만, 추가적인 연산이 필요하여 입출력 속도가 매우 떨어짐.  
>   - 모든 I/O에서 ECC 계산이 필요하므로 입출력 병목 현상이 발생하며, ECC 기록용으로 쓰이는 디스크의 수명이 다른 디스크들에 비해 짧아지는 문제가 있어 현재는 사용하지 않음.
---
>> `패리티란? Data의 오류검출 확인에 사용되는 개념으로, 정보 블록과 연결된 중복 정보. 패리티는 오류 후 데이터를 재구축하는 데 사용되는 계산된 값임`

> - RAID 3 (패리티 사용, 디스크 병렬 처리)  
>   - 최소드라이브 개수 : 3
>   - 최대 용량 : (디스크의 수 - 1) x 각 디스크의 용량
>   - 설명 : 데이터는 바이트 단위로 쪼개져서 모든 디스크에 균등하게 나뉘어 저장되고 패리티 정보는 별도의 전용 디스크에 저장됨.

> 장점
> 1. 한 개의 드라이브가 고장 나는 것을 허용하며 순차적 쓰기(sequential write) 성능과 순차적 읽기(sequential read) 성능이 우수함.

> 단점
> 1. 잘 사용되지 않고 문제를 해결하는 것이 어려울 수 있음. 패리티 디스크가 Fail되면 복구가 불가능하기 때문. 하드웨어 RAID가 되어야 실제로 쓸만함. RAID 3은 보통 매우 효율적이지만 임의 쓰기(random write) 성능이 나쁘고 임의 읽기(random read) 성능은 꽤 좋음.
---
> - RAID 4 (각 디스크가 한개의 패리티 블럭 사용)
>   - 최소 드라이브 개수 : 3
>   - 최대 용량 : (디스크의 수 - 1) x 디스크의 용량
>   - 설명 : 모든 파일은 블럭으로 쪼개지고 각 블럭은 여러 디스크가 저장되지만 균등하진 않음. RAID 3 처럼 RAID 4도 패리티를 처리하기 위해 별도의 디스크를 사용함. 동시 트랜잭션 사용량이 많은 시스템에서 읽기 속도는 매우 중요한데, 이런 시스템에 적합함.  

> 장점
> 1. 드라이브 하나가 고장 나는 것을 허용하고 읽기 성능이 매우 좋음.

> 단점
> 1. 쓰기 성능이 나쁘지만 블럭 읽기(block read) 성능은 괜찮다.

>> `RAID 3과 RAID 4의 차이점 : RAID 3은 Byte 단위로 데이터 저장, RAID 4는 Block 단위로 데이터 저장. (Block 단위로 저장하는 경우, 작은 파일의 경우는 한번의 작업으로 데이터를 읽을 수 있기 때문에 성능상의 장점이 있어 3보단 4를 많이 이용함)`
---
> - RAID 5 (패리티를 순환시키는 것 없이 각 Array에 접근)
>   - 최소 드라이브 개수 : 3
>   - 최대 용량 : (디스크의 수 - 1) x 디스크의 용량
>   - 설명 : RAID 4 처럼 데이터의 블럭은 모든 디스크에 나뉘어 저장되지만 항상 균등하진 않고 패리티 정보도 모든 디스크에 나뉘어 저장됨

> 장점
> 1. 지원하는 회사가 많고, 한 개의 드라이브가 고장나는 것을 허용함.
> 2. RAID 3,4의 단점을 해결한 상태이며, 고급 RAID Controller에서 현재 많이 쓰이고 있는 형태임. 이는 별도의 드라이브를 두지 않고, 각 드라이브에 분산되어 ECC 드라이브에 대한 병목 현상을 막아주며 ECC를 위한 알고리즘 때문에 성능 면에서는 여전히 RAID 0 보다 떨어지지만, 성능, 안전성, 용량의 세 부분을 고려한 형태임

> 단점
> 1. 디스크 재구성(rebuild)이 매우 느리고 쓰기 성능은 패리티 정보를 끊임없이 갱신해야 하기 때문에 우수하다고 할 수는 없음.
---
> - RAID 6 (각 디스크에 패리티 정보가 두 번 독립적으로 분산됨)
>   - 최소 드라이브 개수 : 3
>   - 최대 용량 : (디스크의 수 - 2) x 디스크의 용량
>   - 설명 : RAID 4처럼 데이터의 블럭은 모든 디스크에 나뉘어 저장되지만 항상 균등하진 않고 패리티 정보도 모든 디스크에 나뉘어 저장됨.

> 장점
> 1. 두 개의 드라이브까지 고장 나는 것을 허용하고, 읽기 성능이 우수해 매우 중요한 경우 적합함.

> 단점
> 1. 쓰기 성능은 패리티를 여러 번 갱신해야 하기 때문에 RAID 5보다 매우 나쁨. 디스크를 재 구성하는 동안 성능이 매우 나빠질 수 있음.

### 방화벽의 주요 기능
- 통과시킬 접근과 거부할 접근에 따라 허용 또는 차단을 수행함.
- 허용 또는 차단된 접근에 대한 기록을 유지
- 메시지 인증, 사용자 인증, 클라이언트 인증 등으로 인증을 수행함.

<h2>문제적 읽기</h2>   

<a href="#tcpip_">tcp/ip</a>  
<a href="#네트워크-일반_">네트워크 일반</a>  
<a href="#nos_">NOS</a>  
<a href="#네트워크-운용기기">네트워크 운용기기</a>  

### TCP/IP_
- TCP, UDP port를 함께 사용하는 프로토콜은?  
-\<DNS>  

- 멀티캐스트(Multicast)에 사용되는 IP Class는?  
-\<D Class>

- 프로토콜의 기본적인 기능 중, 송신기에서 발생된 정보의 정확한 전송을 위해 사용자 정보의 앞, 뒤 부분에 헤더와 트레일러를 부가하는 과정은?  
-\<캡슐화(Encapsulation)>  

- 호스트의 IP Address가 '201.100.5.68/28' 일 때, Network ID로 올바른 것은?  
-\<201.100.5.64>

스토리지 에어리어 네트워크(SAN)의 성능이 저하되고 있는 현상을 조사, 관련 사항을 조사하는 중 최근 급증한 업무로 인해 네트워크의 대역폭 부족이 문제임을 알고, 이를 해결하기 위해 기존에 설치된 Gigabit Ethernet 장치를 ()를 활용한 10GBASE-SR나 10GBASE-LRM로 변경하는 방안에 대해 보고  
-\<Optical Fiber Cable>

`DNS에서 사용될 때 TTL(Time to Live)의 설명으로 옳은 것은?`  
-\<데이터가 DNS서버 캐시로부터 나오기 전에 현재 남은 시간이다.>

`UDP 헤더에 포함이 되는 항목은?`  
-\<소스 포트 주소, 체크섬 필드, 목적지 포트 주소>

`IPv6에서 6000Byte의 패킷이 이더넷 LAN을 통과해야 하는 경우 사용할 확장 헤더는?`  
\<Fragmentation>  

`IP 체크섬에 대한 설명으로 올바른 것은?`  
\<IP Header의 완전성을 검사한다.>




### 네트워크 일반_
`LAN의 구성형태 중 중앙의 제어점으로부터 모든 기기가 점대점(Point to Point) 방식으로 연결된 구성형태는?`  
-\<스타형 구성>  

`OSI 7 Layer에서 암호/복호, 인증, 압축 등의 기능이 수행되는 계층은?`  
-\<Presentation Layer>  

`VPN(Virtual Private Network)의 구현 기술 중 인터넷 네트워크 상에서 두 호스트 지점 간 외부의 영향을 받지 않고 가상 경로를 설정해 주는 것은?`  
-\<Tunneling>  



### NOS_

`서버 관리자 Kim 사원이 리눅스서버(하드웨어)의 HDD 증설을 위해 서버를 종료하기로 함. 이에 리눅스서버를 종료하기 위한 명령어가 아닌 것은?`  
-\<shutdown -h now> \<poweroff> <strong>\<init 6> -> 재부팅</strong> \<halt> 

`netstat 명령어에 사용하는 옵션 설명에 대해 옳지 않은 것은?`  
- -r : 라우팅 테이블을 표시
- -p : PID와 사용중인 프로그램명을 출력
- -t : 연결된 이후에 시간을 표시 x (리슨하고 있는 TCP 확인)
- -y : 모든 연결에 대한 TCP 연결 템플릿을 표시 

`Linux 시스템에서 사용되고 있는 메모리양과 사용 가능한 메모리 양, 공유 메모리와 가상 메모리에 대한 정보를 볼 수 있는 명령어는?`  
-\<free>

`Windows Server 2016의 DNS Server 역할에서 지원하는 역방향 조회에 대한 설명으로 옳은 것은?`  
-\<클라이언트가 IP주소를 제공하면 도메인을 반환하는 것>

`Linux Apache 웹서버에 사용자가 접속 후, 80초간 사용자가 요청이 없을 경우 세션을 종료시키도록 'httpd.conf' 파일에서 설정하는 옵션값은?`  
-\<KeepAliveTimeout 80>

## 네트워크 운용기기

`게이트웨이(Gateway)의 역할로 올바른 것은?`  
-\<전혀 다른 프로토콜을 채용한 네트워크 간의 인터페이스 이다.>

